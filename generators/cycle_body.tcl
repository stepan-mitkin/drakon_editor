namespace eval cbody {

variable assign ""
variable compare ""
variable while_start ""
variable if_start ""
variable elseif_start ""
variable if_end ""
variable else_start ""
variable pass ""
variable cont ""
variable return_none ""
variable block_close ""
variable comment ""
# Autogenerated with DRAKON Editor 1.29

proc generate_body { gdb diagram_id start_item node_list items incoming callbacks } {
    #item 76
    save_callbacks $callbacks
    #item 206
    variable comment
    variable block_close
    variable while_start
    variable assign
    set declare [ gen::get_callback $callbacks declare ]
    #item 12
    set result {}
    set count [ llength $items ]
    #item 16
    if {$count == 0} {
        #item 243
        set base 0
    } else {
        #item 27
        array set nodes $node_list
        array set incoming_map $incoming
        set i 0
        set ifs 0
        #item 20
        if {$count == 1} {
            #item 240
            if {$incoming_map($start_item) == 0} {
                #item 24
                set base 0
            } else {
                #item 23
                set base 2
                #item 25
                lappend result [ $declare "int" "_next_item_" "0" ]
                lappend result [ $assign _next_item_ $start_item ]
                lappend result [ $while_start ]
            }
        } else {
            #item 246
            if {$incoming_map($start_item) == 0} {
                #item 256
                set start_node $nodes($start_item)
                #item 257
                if {[ is_init_node $start_node ]} {
                    #item 274
                    unpack [ get_node_text_next $start_node ] text start_item
                    #item 248
                    incr i
                    gen::add_lines result "" $text "" 0 0
                } else {
                    
                }
            } else {
                
            }
            #item 23
            set base 2
            #item 25
            lappend result [ $declare "int" "_next_item_" "0" ]
            lappend result [ $assign _next_item_ $start_item ]
            lappend result [ $while_start ]
        }
        while { 1 } {
            #item 28
            set item_id [ lindex $items $i ]
            set node $nodes($item_id)	
            unpack $node body links
            unpack $body type text b
            #item 45
            set next_i [ expr { $i + 1 } ]
            #item 44
            if {$next_i < $count} {
                #item 46
                set next_item_id [ lindex $items $next_i ]
                set next_incoming $incoming_map($next_item_id)
                #item 47
                if {($next_incoming == 1) && ([ p.one_exit $links $next_item_id ])} {
                    
                } else {
                    #item 48
                    set next_item_id ""
                }
            } else {
                #item 48
                set next_item_id ""
            }
            #item 245
            if {$base == 2} {
                #item 275
                if {$ifs == 0} {
                    #item 30
                    p.if result _next_item_ $item_id 1
                } else {
                    #item 278
                    p.elif result _next_item_ $item_id 1
                }
                #item 279
                incr ifs
            } else {
                #item 52
                gen::add_line result [ $comment "item $item_id" ] 0 1
            }
            #item 320001
            if {$type == "if"} {
                #item 37
                p.generate_if \
                result $links $text $b $base \
                $next_item_id $items $i
            } else {
                #item 66
                p.generate_action \
                result $links $text $base \
                $next_item_id $items $i
            }
            #item 68
            lappend result ""
            #item 58
            incr i
            #item 59
            if {$i < $count} {
                
            } else {
                break
            }
        }
    }
    #item 230
    if {$base == 2} {
        #item 280
        $block_close result 1
        #item 231
        $block_close result 0
    } else {
        
    }
    #item 17
    return $result
}

proc get_node_text_next { node } {
    #item 254
    unpack $node body links
    unpack $body type text b
    #item 270
    if {[ llength $links ] == 0} {
        #item 273
        set next ""
    } else {
        #item 269
        set link0 [ lindex $links 0 ]
        set next [ lindex $link0 0 ]
    }
    #item 255
    return [ list $text $next ]
}

proc is_init_node { node } {
    #item 263
    unpack $node body links
    unpack $body type text b
    #item 265
    if {$type == "action"} {
        #item 264
        return 1
    } else {
        #item 268
        return 0
    }
}

proc p.add_block { output text base jump_item next_item_id items i } {
    #item 175
    upvar 1 $output result
    #item 169
    if {$text == ""} {
        #item 174
        set has_text 0
    } else {
        #item 170
        gen::add_lines result "" $text "" $base 1
        set has_text 1
    }
    #item 173
    p.jump result $jump_item $base 1 $next_item_id $has_text $items $i
}

proc p.elif { output variable constant depth } {
    #item 226
    upvar 1 $output result
    #item 225
    variable elseif_start
    variable if_end
    variable compare
    #item 227
    gen::add_line result \
    "[ $elseif_start ][ $compare $variable $constant ][ $if_end ]" \
    $depth 0
}

proc p.generate_action { output links text base next_item_id items i } {
    #item 181
    upvar 1 $output result
    #item 183
    incr base -1
    #item 184
    set link [ lindex $links 0 ]
    set dst_item [ lindex $link 0 ]
    #item 182
    p.add_block result $text $base $dst_item $next_item_id $items $i
}

proc p.generate_if { output links text b base next_item_id items i } {
    #item 215
    variable if_start
    variable if_end
    variable else_start
    variable block_close
    #item 126
    upvar 1 $output result
    #item 120
    set then_index 1
    set else_index 0
    #item 123
    unpack [ lindex $links $then_index ] then_item foo then_code
    unpack [ lindex $links $else_index ] else_item foo else_code
    #item 124
    gen::add_lines result \
    [ $if_start ] $text [ $if_end ] $base 0
    #item 127
    p.add_block result $then_code $base $then_item $next_item_id $items $i
    #item 125
    gen::add_line result [ $else_start ] $base 0
    #item 128
    p.add_block result $else_code $base $else_item $next_item_id $items $i
    #item 218
    $block_close result $base
}

proc p.if { output variable constant depth } {
    #item 213
    upvar 1 $output result
    #item 212
    variable if_start
    variable if_end
    variable compare
    #item 214
    gen::add_line result \
    "[ $if_start ][ $compare $variable $constant ][ $if_end ]" \
    $depth 0
}

proc p.jump { output item_id base depth next_item_id has_text items i } {
    #item 93
    upvar 1 $output result
    #item 229
    variable return_none
    variable pass
    variable cont
    variable assign
    #item 101
    set next_ordinal [ lsearch $items $item_id ]
    #item 820001
    if {$item_id == "last_item"} {
        #item 90
        gen::add_line result \
        [ $return_none ] $base $depth
    } else {
        #item 820002
        if {$item_id == "has_return"} {
            
        } else {
            #item 105
            gen::add_line result \
            [ $assign _next_item_ $item_id ] $base $depth
        }
    }
}

proc p.one_exit { links item_id } {
    foreach link $links {
        #item 190
        set linked_item [ lindex $link 0 ]
        #item 238
        set found 0
        #item 1930001
        if {$linked_item == $item_id} {
            #item 239
            set found 1
        } else {
            #item 1930002
            if {($linked_item == "last_item") || ($linked_item == "has_return")} {
                
            } else {
                #item 205
                return 0
            }
        }
    }
    #item 204
    return $found
}

proc save_callbacks { callbacks } {
    #item 75
    variable assign
    variable compare
    variable while_start
    variable if_start
    variable elseif_start
    variable if_end
    variable else_start
    variable pass
    variable cont
    variable return_none
    variable block_close
    variable comment
    variable bad_case
    #item 73
    set assign [ gen::get_callback $callbacks assign ]
    set compare [ gen::get_callback $callbacks compare ]
    set while_start [ gen::get_callback $callbacks while_start ]
    set if_start [ gen::get_callback $callbacks if_start ]
    set elseif_start [ gen::get_callback $callbacks elseif_start ]
    set if_end [ gen::get_callback $callbacks if_end ]
    set else_start [ gen::get_callback $callbacks else_start ]
    set pass [ gen::get_callback $callbacks pass ]
    set return_none [ gen::get_callback $callbacks return_none ]
    set block_close [ gen::get_callback $callbacks block_close ]
    set comment [ gen::get_callback $callbacks comment ]
    set bad_case [ gen::get_callback $callbacks bad_case ]
}

}
