/* Autogenerated with DRAKON Editor 1.32 */
#include "c_demo.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#ifdef _MSC_VER
#pragma warning(disable : 4996)
#endif
struct String
{
	char* Buffer;
	int Length;
};
struct ObjectArray
{
	void** Buffer;
	int Count;
	ObjectDestructor ElementDestructor;
};
struct IntArray
{
	int* Buffer;
	int Count;
};
static int Compare(
    struct ObjectArray* collection,
    int firstIndex,
    int secondIndex,
    ObjectComparer comparer
);
static void Fill(
    struct ObjectArray* output,
    const char* strings[]
);
static void IterationDemo(void);
static void Print(
    struct ObjectArray* array
);
static void PrintHello(void);
static void PrintIntsArrow(
    const struct IntArray* collection
);
static void PrintIntsBackward(
    const struct IntArray* collection,
    int n
);
static void PrintIntsFor(
    const struct IntArray* collection
);
static void Put(
    struct ObjectArray* array,
    int index,
    const char* text
);
static void QuickSortDemo(void);
static void SortStrings(
    struct ObjectArray* strings
);
static void StringsAreSorted(
    struct ObjectArray* array
);
static void Swap(
    struct ObjectArray* collection,
    int firstIndex,
    int secondIndex
);
static void alt_select_test(void);
static void alternative_select(
    int value,
    int expected
);
static int Compare(
    struct ObjectArray* collection,
    int firstIndex,
    int secondIndex,
    ObjectComparer comparer
) {
    void* first = ObjectArray_Get(collection, firstIndex);
    void* second = ObjectArray_Get(collection, secondIndex);
    return comparer(first, second);
}
static void Fill(
    struct ObjectArray* output,
    const char* strings[]
) {
    int i = 0;
    const char** current = strings;
    while (true) {
        if (*current == 0) {
            break;
        }
        Put(output, i, *current);
        i++;
        current++;
    }
}
static void IterationDemo(void) {
    int n = 15;
    /* own */
    struct IntArray* sequence = 0;
    printf("iteration demo\n");
    sequence = Fibonacci(n);
    PrintIntsArrow(sequence);
    PrintIntsBackward(sequence, n);
    PrintIntsFor(sequence);
    printf("\n");
    IntArray_Delete(sequence);
}
static void Print(
    struct ObjectArray* array
) {
    int i;
    struct String* item;
    int length = ObjectArray_Count(array);
    i = 0;
    while (true) {
        if (i < length) {
        } else {
            break;
        }
        item = ObjectArray_Get(array, i);
        printf("%s ", String_GetBuffer(item));
        i++;
    }
    printf("\n");
}
static void PrintHello(void) {
    printf("DRAKON-C demo\n");
    printf("=============\n");
}
static void PrintIntsArrow(
    const struct IntArray* collection
) {
    int i, length, item;
    printf("using if and arrow:\n");
    length = IntArray_Count(collection);
    i = 0;
    while (true) {
        if (i < length) {
        } else {
            break;
        }
        item = IntArray_Get(collection, i);
        printf("%d ", item);
        i++;
    }
    printf("\n");
}
static void PrintIntsBackward(
    const struct IntArray* collection,
    int n
) {
    while (true) {
        if (n >= 0) {
        } else {
            break;
        }
        printf("%d ", IntArray_Get(collection, n));
        n--;
    }
    printf("\n");
}
static void PrintIntsFor(
    const struct IntArray* collection
) {
    int i, length, item;
    printf("using for:\n");
    length = IntArray_Count(collection);
    i = 0;
    while (true) {
        if (i < length) {
        } else {
            break;
        }
        item = IntArray_Get(collection, i);
        printf("%d ", item);
        i++;
    }
    printf("\n");
}
static void Put(
    struct ObjectArray* array,
    int index,
    const char* text
) {
    /* Transient ownership. */
    struct String* item;
    item = String_FromCString(text);
    ObjectArray_Put(array, index, item);
}
static void QuickSortDemo(void) {
    /* own */
    struct ObjectArray* unsorted = 0;
    struct ObjectArray* sorted = 0;
    struct ObjectArray* reverse = 0;
    struct ObjectArray* empty = 0;
    struct ObjectArray* flat = 0;
    const char* unsortedA[] = { "the", "sooner", "we", "start", "this", "the", "better", 0 };
    const char* sortedA[] = { "aa", "bb", "cc", "dd", "ee", "ff", 0 };
    const char* reverseA[] = { "ff", "ee", "dd", "cc", "bb", "aa", 0 };
    const char* emptyA[] = { 0 };
    const char* flatA[] = { "flat", "flat", "flat", "flat", "flat", 0};
    printf("quick sort demo\n");
    unsorted = ObjectArray_Create(7, (ObjectDestructor)&String_Delete);
    sorted = ObjectArray_Create(6, (ObjectDestructor)&String_Delete);
    reverse = ObjectArray_Create(6, (ObjectDestructor)&String_Delete);
    empty = ObjectArray_Create(0, (ObjectDestructor)&String_Delete);
    flat = ObjectArray_Create(5, (ObjectDestructor)&String_Delete);
    Fill(unsorted, unsortedA);
    Fill(sorted, sortedA);
    Fill(reverse, reverseA);
    Fill(empty, emptyA);
    Fill(flat, flatA);
    SortStrings(unsorted);
    SortStrings(sorted);
    SortStrings(reverse);
    SortStrings(empty);
    SortStrings(flat);
    Print(unsorted);
    Print(sorted);
    Print(reverse);
    Print(empty);
    Print(flat);
    StringsAreSorted(unsorted);
    StringsAreSorted(sorted);
    StringsAreSorted(reverse);
    StringsAreSorted(empty);
    StringsAreSorted(flat);
    ObjectArray_Delete(unsorted);
    ObjectArray_Delete(sorted);
    ObjectArray_Delete(reverse);
    ObjectArray_Delete(empty);
    ObjectArray_Delete(flat);
}
static void SortStrings(
    struct ObjectArray* strings
) {
    ObjectComparer comparer = (ObjectComparer)&String_Compare;
    int length = ObjectArray_Count(strings);
    QuickSort(strings, 0, length, comparer);
}
static void StringsAreSorted(
    struct ObjectArray* array
) {
    int _sw6930000_ = 0;
    int i, j;
    struct String* current;
    struct String* after;
    int length = ObjectArray_Count(array);
    int _next_item_ = 0;
    _next_item_ = 6830001;
    while (true) {
        if (_next_item_ == 6830001) {
            i = 0;
            _next_item_ = 6830002;
        } else if (_next_item_ == 6830002) {
            if (i < length) {
                current = ObjectArray_Get(array, i);
                _next_item_ = 6860001;
            } else {
                return;
            }
        } else if (_next_item_ == 6860001) {
            j = i + 1;
            _next_item_ = 6860002;
        } else if (_next_item_ == 6860002) {
            if (j < length) {
                after = ObjectArray_Get(array, j);
                _next_item_ = 6930000;
            } else {
                i += 1;
                _next_item_ = 6830002;
            }
        } else if (_next_item_ == 6930000) {
            _sw6930000_ = String_Compare(current, after);
            _next_item_ = 6930001;
        } else if (_next_item_ == 6930001) {
            if (_sw6930000_ == -1) {
                _next_item_ = 6860003;
            } else {
                _next_item_ = 6930002;
            }
        } else if (_next_item_ == 6930002) {
            if (_sw6930000_ == 0) {
                _next_item_ = 6860003;
            } else {
                _next_item_ = 6930003;
            }
        } else if (_next_item_ == 6860003) {
            j += 1;
            _next_item_ = 6860002;
        } else if (_next_item_ == 6930003) {
            if (_sw6930000_ == 1) {
                _next_item_ = 702;
            } else {
                throw new Exception("Not expected _sw6930000_");
            }
        } else if (_next_item_ == 702) {
            _next_item_ = 689;
        } else if (_next_item_ == 689) {
            printf("Collection is not sorted.\n");
            abort();
            return;
        }
    }
}
static void Swap(
    struct ObjectArray* collection,
    int firstIndex,
    int secondIndex
) {
    if (firstIndex == secondIndex) {
    } else {
        void* first = ObjectArray_Get(collection, firstIndex);
        void* second = ObjectArray_Get(collection, secondIndex);
        ObjectArray_Put(collection, firstIndex, second);
        ObjectArray_Put(collection, secondIndex, first);
    }
}
static void alt_select_test(void) {
    alternative_select(-100, -1);
    alternative_select(100, 1);
    alternative_select(0, 0);
}
static void alternative_select(
    int value,
    int expected
) {
    int actual;
    if (value < 0) {
        actual = -1;
    } else {
        if (value == 0) {
            actual = 0;
        } else {
            actual = 1;
        }
    }
    if (actual == expected) {
    } else {
        printf("alt select failure!\n");
        abort();
    }
    if (value < 0) {
        actual = -1;
    } else {
        if (value == 0) {
            actual = 0;
        } else {
            if (value > 0) {
            } else {
                throw new Exception("Not expected condition.");
            }
            actual = 1;
        }
    }
    if (actual == expected) {
    } else {
        printf("alt select failure!\n");
        abort();
    }
}
struct IntArray* Fibonacci(
    int n
) {
    int i, f1, f2, fib;
    /* own */
    struct IntArray* result = 0;
    if (n == 0) {
        result = IntArray_Create(1);
        IntArray_Put(result, 0, 0);
    } else {
        if (n == 1) {
            result = IntArray_Create(2);
            IntArray_Put(result, 0, 0);
            IntArray_Put(result, 1, 1);
        } else {
            result = IntArray_Create(n + 1);
            IntArray_Put(result, 0, 0);
            IntArray_Put(result, 1, 1);
            i = 2;
            while (true) {
                if (i <= n) {
                } else {
                    break;
                }
                f2 = IntArray_Get(result, i - 2);
                f1 = IntArray_Get(result, i - 1);
                fib = f1 + f2;
                IntArray_Put(result, i, fib);
                i += 1;
            }
        }
    }
    return result;
}
int IntArray_Count(
    const struct IntArray* object
) {
    if (object == 0) {
        printf("IntArray_Count: object is null.\n");
        abort();
    }
    return object->Count;
}
struct IntArray* IntArray_Create(
    int size
) {
    /* own */
    struct IntArray* object = 0;
    if (size < 0) {
        printf("IntArray_Create: size is negative.\n");
        abort();
    }
    object = Memory_Allocate(1, sizeof(struct IntArray));
    object->Count = size;
    if (size == 0) {
        object->Buffer = 0;
    } else {
        object->Buffer = Memory_Allocate(size, sizeof(int));
    }
    return object;
}
void IntArray_Delete(
    struct IntArray* object
) {
    if (object == 0) {
    } else {
        Memory_Free(object->Buffer);
        Memory_Free(object);
    }
}
int IntArray_Get(
    const struct IntArray* object,
    int index
) {
    if (object == 0) {
        printf("IntArray_Get: object is null.\n");
        abort();
    }
    if ((index < 0) || (index >= object->Count)) {
        printf("IntArray_Get: index out of range. Index=%d\n", index);
        abort();
    }
    return object->Buffer[index];
}
void IntArray_Put(
    struct IntArray* object,
    int index,
    int value
) {
    if (object == 0) {
        printf("IntArray_Put: object is null.\n");
        abort();
    }
    if ((index < 0) || (index >= object->Count)) {
        printf("IntArray_Put: index out of range. Index=%d\n", index);
        abort();
    }
    object->Buffer[index] = value;
}
void* Memory_Allocate(
    int numOfObjects,
    int objectSize
) {
    /* own */
    void* buffer = 0;
    if (objectSize <= 0) {
        printf("Memory_Allocated: non-positive objectSize: %d\n", objectSize);
        abort();
    }
    if (numOfObjects <= 0) {
        printf("Memory_Allocated: non-positive numOfObjects: %d\n", numOfObjects);
        abort();
    }
    buffer = calloc(
    	(size_t)numOfObjects,
    	(size_t)objectSize);
    if (buffer == 0) {
        printf(
        "Memory_Allocated: could not allocate memory: numOfObjects=%d, objectSize=%d\n", 
        numOfObjects, objectSize);
        abort();
    }
    return buffer;
}
void Memory_Free(
    void* buffer
) {
    if (buffer == 0) {
    } else {
        free(buffer);
    }
}
int ObjectArray_Count(
    const struct ObjectArray* object
) {
    if (object == 0) {
        printf("ObjectArray_Count: object is null.\n");
        abort();
    }
    return object->Count;
}
struct ObjectArray* ObjectArray_Create(
    int size,
    ObjectDestructor elementDestructor
) {
    /* own */
    struct ObjectArray* object = 0;
    if (size < 0) {
        printf("ObjectArray_Create: size is negative.\n");
        abort();
    }
    object = Memory_Allocate(1, sizeof(struct ObjectArray));
    object->Count = size;
    object->ElementDestructor = elementDestructor;
    if (size == 0) {
        object->Buffer = 0;
    } else {
        object->Buffer = Memory_Allocate(size, sizeof(void*));
    }
    return object;
}
void ObjectArray_Delete(
    struct ObjectArray* object
) {
    int i;
    if (object == 0) {
    } else {
        if (object->ElementDestructor == 0) {
        } else {
            i = 0;
            while (true) {
                if (i < object->Count) {
                } else {
                    break;
                }
                object->ElementDestructor(object->Buffer[i]);
                i++;
            }
        }
        Memory_Free(object->Buffer);
        Memory_Free(object);
    }
}
void* ObjectArray_Get(
    struct ObjectArray* object,
    int index
) {
    if (object == 0) {
        printf("ObjectArray_Get: object is null.\n");
        abort();
    }
    if ((index < 0) || (index >= object->Count)) {
        printf("ObjectArray_Get: index out of range. Index=%d\n", index);
        abort();
    }
    return object->Buffer[index];
}
void ObjectArray_Put(
    struct ObjectArray* object,
    int index,
    void* value
) {
    if (object == 0) {
        printf("ObjectArray_Put: object is null.\n");
        abort();
    }
    if ((index < 0) || (index >= object->Count)) {
        printf("ObjectArray_Put: index out of range. Index=%d\n", index);
        abort();
    }
    object->Buffer[index] = value;
}
void QuickSort(
    struct ObjectArray* collection,
    int begin,
    int end,
    ObjectComparer comparer
) {
    int i;
    int pivotIndex;
    int storeIndex;
    int length = end - begin;
    int last = end - 1;
    if ((length == 0) || (length == 1)) {
    } else {
        if (length == 2) {
            if (Compare(collection, begin, last, comparer) <= 0) {
            } else {
                Swap(collection, begin, last);
            }
        } else {
            pivotIndex = begin + length / 2;
            Swap(collection, pivotIndex, last);
            storeIndex = begin;
            i = begin;
            while (true) {
                if (i < last) {
                } else {
                    break;
                }
                if (Compare(collection, i, last, comparer) < 0) {
                    Swap(collection, i, storeIndex);
                    storeIndex++;
                }
                i++;
            }
            Swap(collection, storeIndex, last);
            QuickSort(collection, begin, storeIndex, comparer);
            QuickSort(collection, storeIndex + 1, end, comparer);
        }
    }
}
int String_Compare(
    const struct String* left,
    const struct String* right
) {
    int i;
    int leftChar, rightChar;
    int result = 200;
    if (left == 0) {
        printf("String_Compare: left is null.\n");
        abort();
    }
    if (right == 0) {
        printf("String_Compare: right is null.\n");
        abort();
    }
    if (left == right) {
        result = 0;
    } else {
        i = 0;
        while (true) {
            if ((i < left->Length) && (i < right->Length)) {
            } else {
                if (left->Length < right->Length) {
                    result = -1;
                } else {
                    if (left->Length > right->Length) {
                        result = 1;
                    } else {
                        result = 0;
                    }
                }
                break;
            }
            leftChar = left->Buffer[i];
            rightChar = right->Buffer[i];
            if (leftChar < rightChar) {
                result = -1;
                break;
            }
            if (leftChar > rightChar) {
                result = 1;
                break;
            }
            i++;
        }
    }
    return result;
}
void String_Delete(
    struct String* object
) {
    if (object == 0) {
    } else {
        Memory_Free(object->Buffer);
        Memory_Free(object);
    }
}
struct String* String_FromCString(
    const char* text
) {
    int length;
    /* own */
    struct String* string = 0;
    if (text == 0) {
        printf("String_FromCString: text argument is null.\n");
        abort();
    }
    length = (int)strlen(text);
    string = Memory_Allocate(1, sizeof(struct String));
    string->Buffer = Memory_Allocate(length + 1, sizeof(char));
    string->Length = length;
    strncpy(string->Buffer, text, length);
    return string;
}
const char* String_GetBuffer(
    const struct String* object
) {
    if (object == 0) {
        printf("String_Buffer: object is null.\n");
        abort();
    }
    return object->Buffer;
}
void UnexpectedBranch(
    int switchValue
) {
    printf("An unexpected value in the 'select' ('switch') construct: %d\n", switchValue);
    abort();
}
int main(
    int argc,
    char** argv
) {
    int result = 0;
    PrintHello();
    alt_select_test();
    IterationDemo();
    QuickSortDemo();
    return result;
}
/* End of C file. */
